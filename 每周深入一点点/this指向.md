# this指向✌️
>虽然js中是静态作用域，但this像动态作用域
1. **默认绑定** 
>在非严格模式下this指向的是全局对象window，而在严格模式下会绑定到undefined。

var let const
- 块级作用域（花括号） 
解决了内部变量覆盖外层变量的问题和计数的循环变量泄漏为全局变量
- 暂时性死区，不存在变量提升
- 不允许重复声明变量
- 声明的全局变量不会挂在顶层变量下面
- const常量let变量
- const在 声明之后必须马上赋值
2. **隐式绑定**
>this 永远指向**最后调用**它的那个对象

隐式丢失(本质还是找**最后调用**)
- 使用另一个变量来给函数取别名
  ```
  function foo () {
    console.log(this.a)
  };
  var obj = { a: 1, foo };
  var a = 2;
  var foo2 = obj.foo;

  obj.foo();//1
  foo2();//2

  ```
- 将函数作为参数传递时
如果你把一个函数当成参数传递到另一个函数的时候，也会发生隐式丢失的问题，且与包裹着它的函数的this指向无关。在非严格模式下，会把该函数的this绑定到window上，严格模式下绑定到undefined
3. **显示绑定**
匿名函数this是window
4. **new绑定**
5. **箭头函数**
>this由外层作用域决定，且指向函数定义时的this而非执行
箭头函数的this无法通过bind、call、apply来直接修改，但是可以通过改变作用域中this的指向来间接修改。