# 输入url后发生了什么➡️
1. DNS将URL解析为IP

   - 有缓存，直接返回缓存
   - 无缓存，继续递归解析


2. DNS解析得到服务器的IP，与服务器建立TCP连接

   - IP协议：选择传输路线，负责找到
   - TCP协议：三次握手、分片、可靠传输、重新发送的机制


3. 浏览器通过http协议发送请求

    - 请求行、请求头、请求体


4. 服务器接收请求后，开始查库，读文件，拼接要返回的http响应
5. 浏览器收到html文件开始渲染
6. 解析html为dom树，解析css为css-tree，最终生成render-tree 渲染树，阻塞渲染
7. 遍历渲染树开始布局，计算每个节点的大小位置信息
8. 将渲染树每个节点绘制到页面上
9. 加载js文件，执行js脚本
10. 回流reflow和重绘repaint
###### 浏览器解析
>内核是渲染引擎 Blink（基于 Webkit）和 JavaScript 引擎 V8.
浏览器结合 DOM 树和 CSSOM 树构建 Render 树，并计算布局属性，绘制
###### http/https/https 1.1/https 2.0
- https = http + ssl/tls
加了一层ssl协议，来进行加密
- http1.1支持
长链接：减少了TCP建立和关闭连接的消耗和延迟，一次建立多次请求和响应
缓存处理：支持了更多的缓存策略，Etag、If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match、Cache-Control
Host头处理：同一台机器上，可能部署多个app，通过解析host+端口，指定具体访问站点
- http2.0支持
头部压缩：体积压缩；对传输过的header进行缓存，如果有传输过header的键名，就不再重复发送了，减少了传输的大小
多路复用：在一个TCP连接中可以同时发送多个请求
服务端推送：服务端主动的把你必定需要的资源推送给你，让你在请求一次的情况下得到多个响应数据
###### 状态码
- 2xx - **成功系列**

  200 - 请求成功
  204  - 返回响应头，不带响应体(如：打点请求)
  206  - 返回部分数据(如：断点续传)

- 3xx - **重定向系列**

  301 - 永久重定向
  302 - 临时重定向
  303 - 只能用get请求的临时重定向
  **304 - 没有更改(主要用来处理缓存)**
  307 - 不改变请求方法的临时重定向

- 4xx - **客户端错误系列**⚠️

  400 - 请求报文语法错误
  401 - 需要认证
  403 - 拒绝访问资源
  404 - 文件不存在

- 5xx - **服务器错误系列**

  500 - 服务器故障
  503 - 服务器宕机了
###### 缓存策略
- 强制缓存
  >强制缓存通常是用在图片或者logo这样长久不会更改的资源上的
  当第一次访问资源的时候，会正常拿到**200**的状态码
  当第二次访问资源的时候，就会去浏览器的缓存里找缓存文件使用了，不过返回的状态码仍然是**200**

  强制缓存主要是通过响应头Cache-Control和Expires来设置的
  Cache-Control： 相对时间，http1.1里添加的字段，优先级更高
  Expires：绝对时间，很早就有了，为了兼容低版本
- 协商缓存
  >当第一次访问资源的时候，会正常拿到200的状态码，服务端会把缓存标识和数据一起返回
  当第二次访问资源的时候，就会把缓存标识发给服务端，服务端去校验是否匹配，匹配成功就返回304，直接使用缓存即可

  协商缓存常见的也是两种，一种是Last-Modified，另一种是Etag
  Last-Modified：服务端会通过客户端发来的If-Modified-Since和本地的Last-Modified的值比对
  Etag：服务端会通过客户端发来的If-None-Match和Etag的值比较
- 强制不缓存
  设置Cache-Control: no-store
  no-cache这个值，实际上它依然会缓存但是每次都像服务器发请求罢了
###### tcp三次握手四次挥手
>TCP是**全双工通信**，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。
- 三次握手
  >双方都能明确自己和对方的收、发能力是正常的
  1. 客户端向服务端发送序列号
  2. 服务端收到后，向客户端发序列号和确认号
  3. 客户端收到后，向服务端发确认号
- 四次挥手
  >双方数据都发送完毕了，都觉得可以断开了
  1. 客户端向服务端发送结束号
  2. 服务端收到后，向客户端发送确认号
  3. 数据传送完后，服务端向客户端发送结束号
  4. 客户端收到后，向服务端发送确认号
###### cdn
- 缓存
- 节省服务器流量
- 最近节点优先
###### cookie
- 为了解决 HTTP 无状态导致的问题,解决客户端与服务端会话状态的问题
- 服务器产生，浏览器存储，每次http请求会自动携带cookie
- 属性
   - Expires：有过期时间的是持久性cookie存在硬盘中，浏览器关闭不消失，反之是会话性cookie
   - Domain：一般设置成二级域名，这样子域名可以共享
   - SameSite：之前默认是 None（无论是否跨站都会发送 Cookie） 的，Chrome80 后默认是 Lax （允许部分第三方请求携带 Cookie）。
   - HttpOnly：禁止用户通过 JavaScript 操作 cookie，防止窃取cookie
## 性能优化
#### http方面
>减少请求次数
减少单次请求所花费的时间

1. webpack资源的压缩与合并
2. 按需加载
- 路由,es提案的import
- 组件库
- 图片懒加载
3. 选择图片格式问题（权衡）
- jpg 有损压缩 轮播图
- png 无损压缩 高保真
- svg 矢量图 不失真 渲染成本
- Base64 减少http请求次数 小图标解决方案 雪碧图
>在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。

- Webp 综合了jpg和png的优点 safari兼容性问题 
  
4. 缓存策略
- cdn缓存 静态资源（js、css、html）
- Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。
> 静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！

#### 渲染
1. 服务器渲染 提高seo和首屏渲染 消耗服务器资源
2. 编码习惯
- 不直接写标签定义选择器
- css阻塞形成渲染树 所以提前
- Js阻塞渲染引擎 异步加载立即执行用async 异步加载最后执行用defer
> 构建dom树（根据html代码自顶向下进行构建），并且在同时构建渲染树。Css阻塞渲染、js阻塞解析也阻塞渲染，所以css放前面可以与dom一起解析，dom树边解析边渲染，js放后面

- 减少重绘重排 vue文档碎片
一个宏任务 —> 一队微任务 —> 渲染
当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。
