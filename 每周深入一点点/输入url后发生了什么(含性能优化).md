# 输入url后发生了什么➡️
1. 浏览器调用**DNS解析域名**为IP
2. 有**CDN缓存**的话，会根据**地理位置**信息解析对应的IP地址，使得用户能就近访问
3. **HTTP协议**建立了链接，找到了目标服务器的位置
4. **TCP三次握手**建立可靠链接，发送数据，服务器处理数据，TCP四次挥手断开链接
5. 浏览器根据返回的数据解析渲染呈现页面
>浏览器http请求缓存机制
强缓存200(响应头cache-control字段决定)、协商缓存304(判断服务器资源是否变化决定命中与否)

- 浏览器解析
>内核是渲染引擎 Blink（基于 Webkit）和 JavaScript 引擎 V8.
浏览器结合 DOM 树和 CSSOM 树构建 Render 树，并计算布局属性，绘制

## 性能优化
#### http方面
>减少请求次数
减少单次请求所花费的时间

1. webpack资源的压缩与合并
2. 按需加载
- 路由,es提案的import
- 组件库
- 图片懒加载
3. 选择图片格式问题（权衡）
- jpg 有损压缩 轮播图
- png 无损压缩 高保真
- svg 矢量图 不失真 渲染成本
- Base64 减少http请求次数 小图标解决方案 雪碧图
>在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。

- Webp 综合了jpg和png的优点 safari兼容性问题 
  
4. 缓存策略
- cdn缓存 静态资源（js、css、html）
- Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。
> 静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！

#### 渲染
1. 服务器渲染 提高seo和首屏渲染 消耗服务器资源
2. 编码习惯
- 不直接写标签定义选择器
- css阻塞形成渲染树 所以提前
- Js阻塞渲染引擎 异步加载立即执行用async 异步加载最后执行用defer
> 构建dom树（根据html代码自顶向下进行构建），并且在同时构建渲染树。Css阻塞渲染、js阻塞解析也阻塞渲染，所以css放前面可以与dom一起解析，dom树边解析边渲染，js放后面

- 减少重绘重排 vue文档碎片
一个宏任务 —> 一队微任务 —> 渲染
当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。
