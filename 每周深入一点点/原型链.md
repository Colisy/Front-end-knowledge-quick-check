# 原型链
![](./imgs/@原型链.jpg)
- 实例对象的隐式原型指向其构造函数的显示原型
- 构造函数都是Function的实例对象
- 显性原型都是Object的实例对象
- Object.prototype的隐性原型指向null
## 继承
1. 原型继承
   
   `Man.prototype = new People();`
   
   **原型上的属性**是所有子类实例共享的，改变一个全都变
2. 构造继承
   
   ```
    function Man(name) {
      People.call(this);
    }
   ```
   无法继承原型上的方法，而且方法不在原型上浪费了内存
3. 寄生组合继承
   
    ```
    //继承父类给予实例的属性和方法
    function Man(name) {
      People.call(this);
    }

    //继承父类原型上的属性和方法
    Man.prototype = Object.create(People.prototype, {
      constructor: {
        value: Man
      }
    })
    ```  
4. es6 
    ```
    class Peple {
      constructor(){

      }
    }
    class Man extends Peple{
      constructor(){
        super()
      }
    }
    ```
## new
1. 创建一个空的对象（即{}）；
2. 设置该对象的构造函数,即确定隐性原型指向构造函数显性原型；
3. 执行构造函数，this指向之前新建空对象；
4. 如果该函数没有返回值，则返回this。

```
var obj = {};
    
obj.__proto__ = arguments[ 0 ].prototype;

var res = arguments[ 0 ].apply(obj, Array.prototype.slice.call(arguments).slice(1));

return ( res instanceof Object ) ? res : obj;
```