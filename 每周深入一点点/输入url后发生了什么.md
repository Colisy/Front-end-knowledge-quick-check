# 输入url后发生了什么➡️
- DNS解析域名为IP
- TCP连接
- HTTP请求
>浏览器http请求缓存机制
强缓存200(响应头cache-control字段决定)、协商缓存304(判断服务器资源是否变化决定命中与否)

- 浏览器解析
>内核是渲染引擎 Blink（基于 Webkit）和 JavaScript 引擎 V8.
浏览器结合 DOM 树和 CSSOM 树构建 Render 树，并计算布局属性，绘制

## 性能优化
#### http方面
>减少请求次数
减少单次请求所花费的时间

1. webpack资源的压缩与合并
2. 按需加载
- 路由,es提案的import
- 组件库
- 图片懒加载
3. 选择图片格式问题（权衡）
- jpg 有损压缩 轮播图
- png 无损压缩 高保真
- svg 矢量图 不失真 渲染成本
- Base64 减少http请求次数 小图标解决方案 雪碧图
>在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。

- Webp 综合了jpg和png的优点 safari兼容性问题 
  
4. 缓存策略
- cdn缓存 静态资源（js、css、html）
- Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。
> 静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！

#### 渲染
1. 服务器渲染 提高seo和首屏渲染 消耗服务器资源
2. 编码习惯
- 不直接写标签定义选择器
- css阻塞形成渲染树 所以提前
- Js阻塞渲染引擎 异步加载立即执行用async 异步加载最后执行用defer
> Css阻塞渲染、js阻塞解析也阻塞渲染，所以css放前面可以与dom一起解析，js放后面

- 减少重绘重排 vue文档碎片
一个宏任务 —> 一队微任务 —> 渲染
当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。
## 最近解决的难题
- 切换数据，表格组件重置，v-if，先用定时器控制表格恢复，但会出现短暂白屏，应该是因为在执行下一个宏任务之前进行了渲染，所以选择放入微任务中，promise.resolve().then()
- Main.js文件包含了第三方库的内容，导致体积过大，首屏时间慢，用webpack实现了代码分割，请求时间有效缩短
