# 记录一次性能优化
> 前端作为页面的直接负责人，当遇到性能问题的时候会被第一个拿出来质问，作为前端必须掌握分析问题定位问题的能力，并且除了改进开发外，也要协调其他部门一起改进
## 分析和定位问题
## 前端方面
## 与UI讨论图片规范
## gzip












与UI讨论规范图片格式
gzip
loading
伪服务器渲染
预渲染插件prerender-spa-plugin解决vue的SPA项目的SEO问题
在本地模拟浏览器环境,预先执行我们的打包文件
开启http2
浏览器并发限制,我们最多一次性请求 6 次,
http2 可以进行多路复用,即跟同一个域名通信,仅需要一个 TCP 建立请求通道,请求与响应可以同时基于此通道进行双向通信,而 http1.x 每次请求需要建立 TCP,多次请求需要多次连接,还有并发限制,十分耗时
http2 可以头部压缩
服务端推送
我们平时解析 HTML 后碰到相关标签才会进而请求 css 和 js 资源,而 http2 可以直接将相关资源直接推送,无需请求,这大大减少了多次请求的耗时
开启浏览器缓存
第三方库和我们的代码需要分开打包,我们可以给第三方库设置一个较长的强缓存时间,这样就不会频繁请求第三方库的代码了。
SplitChunksPlugin
对 chunk 进行 hash 化
开启 hashchunk,它的作用是当 chunk 发生改变的时候会生成新的 hash 值,如果不变就不发生变动,这样当 index 加载后续 script资源时如果 hashchunk 没变就会命中缓存,如果改变了那么会重新去服务端加载新资源。
http 缓存+webpack hash 缓存策略
骨架屏
vue插件 vue-skeleton-webpack-plugin

坑 1: Babel 转译,我们已经提到用Tree Shaking的时候必须用 es6 的module,如果用 common.js那种动态module,Tree Shaking就失效了,但是 Babel 默认状态下是启用 common.js的,所以需要我们手动关闭.

坑 2: 第三方库不可控,我们已经知道Tree Shaking的程序分析依赖 ESM,但是市面上很多库为了兼容性依然只暴露出了ES5 版本的代码,这导致Tree Shaking对很多第三方库是无效的,所以我们要尽量依赖有 ESM 的库,比如之前有一个 ESM 版的 lodash(lodash-es),我们就可以这样引用了import { dobounce } from 'lodash-es'
Lighthouse
思想 分割 按需加载
组件懒加载 组件预加载
 hover 状态的时候就开始触发图表资源的加载
 keep-alive
 如果大量实例不销毁保存在内存中,那么这个 API 存在内存泄漏的风险,所以要注意调用deactivated销毁。
 大量数据性能优化


 虚拟列表

可视区域渲染

可视区域 真实列表

使用一个元素来撑起整个真实列表，让列表的滚动条出现。

监听可视区域滚动行为，向上滑动时，真实列表下移，列表数据startIndex endIndex 相应增加

无限滚动

监听父元素的 scroll 事件
scrollHeight - scrollTop > 可视区域 加载更多的数据