# 复杂度分析

## 为什么需要复杂度分析
- 测试结果非常依赖**测试环境**
- 测试结果受**数据规模**的影响很大
## 时间复杂度
定义：代码**执行时间**随**数据规模**增长的变化趋势

1. 只关注**循环**执行次数最多的一段代码
2. 加法法则：总的时间复杂度就等于量级最大的那段代码的时间复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

几种常见时间复杂度

1. O(1)
   
   一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. O(logn)、O(nlogn)

    log3n = log32 * log2n

    在采用大 O 标记复杂度的时候，可以忽略系数

    因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)
3. O(m+n)、O(m*n)

## 最好、最坏、平均、均摊时间复杂度
平均时间复杂度本质是 加权平均值 期望值 

均摊时间复杂度就是一种特殊的平均时间复杂度

```
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

>每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。

## 空间复杂度分析
定义：算法的**存储空间**与**数据规模**之间的增长关系

我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )

长度为n的数组，空间复杂度是 O(n)
